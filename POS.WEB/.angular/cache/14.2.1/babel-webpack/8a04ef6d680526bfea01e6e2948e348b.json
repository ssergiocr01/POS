{"ast":null,"code":"import { ɵNG_PIPE_DEF } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nconst NG_PIPE_DEF = ɵNG_PIPE_DEF;\n\nfunction isPipe(target) {\n  return !!target[NG_PIPE_DEF];\n}\n\nfunction isFunction(target) {\n  return typeof target === 'function';\n}\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\n\n\nconst DESTROY = Symbol('__destroy');\n/**\n * Applied to definitions and informs that class is decorated\n */\n\nconst DECORATOR_APPLIED = Symbol('__decoratorApplied');\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\n\nfunction getSymbol(destroyMethodName) {\n  if (typeof destroyMethodName === 'string') {\n    return Symbol(`__destroy__${destroyMethodName}`);\n  } else {\n    return DESTROY;\n  }\n}\n\nfunction markAsDecorated(type) {\n  // Store this property on the prototype if it's an injectable class, component or directive.\n  // We will be able to handle class extension this way.\n  type.prototype[DECORATOR_APPLIED] = true;\n}\n\nfunction createSubjectOnTheInstance(instance, symbol) {\n  if (!instance[symbol]) {\n    instance[symbol] = new Subject();\n  }\n}\n\nfunction completeSubjectOnTheInstance(instance, symbol) {\n  if (instance[symbol]) {\n    instance[symbol].next();\n    instance[symbol].complete(); // We also have to re-assign this property thus in the future\n    // we will be able to create new subject on the same instance.\n\n    instance[symbol] = null;\n  }\n}\n\nfunction unsubscribe(property) {\n  property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\n\nfunction unsubscribeIfPropertyIsArrayLike(property) {\n  Array.isArray(property) && property.forEach(unsubscribe);\n}\n\nfunction decorateNgOnDestroy(ngOnDestroy, options) {\n  return function () {\n    var _a; // Invoke the original `ngOnDestroy` if it exists\n\n\n    ngOnDestroy && ngOnDestroy.call(this); // It's important to use `this` instead of caching instance\n    // that may lead to memory leaks\n\n    completeSubjectOnTheInstance(this, getSymbol()); // Check if subscriptions are pushed to some array\n\n    if (options.arrayName) {\n      return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);\n    } // Loop through the properties and find subscriptions\n\n\n    if (options.checkProperties) {\n      for (const property in this) {\n        if ((_a = options.blackList) === null || _a === void 0 ? void 0 : _a.includes(property)) {\n          continue;\n        }\n\n        unsubscribe(this[property]);\n      }\n    }\n  };\n}\n\nfunction decorateProviderDirectiveOrComponent(type, options) {\n  type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n}\n\nfunction decoratePipe(type, options) {\n  const def = type.ɵpipe;\n  def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n}\n\nfunction UntilDestroy(options = {}) {\n  return type => {\n    if (isPipe(type)) {\n      decoratePipe(type, options);\n    } else {\n      decorateProviderDirectiveOrComponent(type, options);\n    }\n\n    markAsDecorated(type);\n  };\n}\n\nfunction overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {\n  const originalDestroy = instance[destroyMethodName];\n\n  if (ngDevMode && isFunction(originalDestroy) === false) {\n    throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);\n  }\n\n  createSubjectOnTheInstance(instance, symbol);\n\n  instance[destroyMethodName] = function () {\n    originalDestroy.apply(this, arguments);\n    completeSubjectOnTheInstance(this, symbol); // We have to re-assign this property back to the original value.\n    // If the `untilDestroyed` operator is called for the same instance\n    // multiple times, then we will be able to get the original\n    // method again and not the patched one.\n\n    instance[destroyMethodName] = originalDestroy;\n  };\n}\n\nfunction untilDestroyed(instance, destroyMethodName) {\n  return source => {\n    const symbol = getSymbol(destroyMethodName); // If `destroyMethodName` is passed then the developer applies\n    // this operator to something non-related to Angular DI system\n\n    if (typeof destroyMethodName === 'string') {\n      overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n    } else {\n      ngDevMode && ensureClassIsDecorated(instance);\n      createSubjectOnTheInstance(instance, symbol);\n    }\n\n    return source.pipe(takeUntil(instance[symbol]));\n  };\n}\n\nfunction ensureClassIsDecorated(instance) {\n  const prototype = Object.getPrototypeOf(instance);\n  const missingDecorator = !(DECORATOR_APPLIED in prototype);\n\n  if (missingDecorator) {\n    throw new Error('untilDestroyed operator cannot be used inside directives or ' + 'components or providers that are not decorated with UntilDestroy decorator');\n  }\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { UntilDestroy, untilDestroyed };","map":{"version":3,"names":["ɵNG_PIPE_DEF","Subject","takeUntil","NG_PIPE_DEF","isPipe","target","isFunction","DESTROY","Symbol","DECORATOR_APPLIED","getSymbol","destroyMethodName","markAsDecorated","type","prototype","createSubjectOnTheInstance","instance","symbol","completeSubjectOnTheInstance","next","complete","unsubscribe","property","unsubscribeIfPropertyIsArrayLike","Array","isArray","forEach","decorateNgOnDestroy","ngOnDestroy","options","_a","call","arrayName","checkProperties","blackList","includes","decorateProviderDirectiveOrComponent","decoratePipe","def","ɵpipe","onDestroy","UntilDestroy","overrideNonDirectiveInstanceMethod","originalDestroy","ngDevMode","Error","constructor","name","apply","arguments","untilDestroyed","source","ensureClassIsDecorated","pipe","Object","getPrototypeOf","missingDecorator"],"sources":["C:/Projects/Sistema POS 2022/SirPosFront14/node_modules/@ngneat/until-destroy/__ivy_ngcc__/fesm2015/ngneat-until-destroy.js"],"sourcesContent":["import { ɵNG_PIPE_DEF } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nconst NG_PIPE_DEF = ɵNG_PIPE_DEF;\nfunction isPipe(target) {\n    return !!target[NG_PIPE_DEF];\n}\n\nfunction isFunction(target) {\n    return typeof target === 'function';\n}\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\nconst DESTROY = Symbol('__destroy');\n/**\n * Applied to definitions and informs that class is decorated\n */\nconst DECORATOR_APPLIED = Symbol('__decoratorApplied');\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\nfunction getSymbol(destroyMethodName) {\n    if (typeof destroyMethodName === 'string') {\n        return Symbol(`__destroy__${destroyMethodName}`);\n    }\n    else {\n        return DESTROY;\n    }\n}\nfunction markAsDecorated(type) {\n    // Store this property on the prototype if it's an injectable class, component or directive.\n    // We will be able to handle class extension this way.\n    type.prototype[DECORATOR_APPLIED] = true;\n}\nfunction createSubjectOnTheInstance(instance, symbol) {\n    if (!instance[symbol]) {\n        instance[symbol] = new Subject();\n    }\n}\nfunction completeSubjectOnTheInstance(instance, symbol) {\n    if (instance[symbol]) {\n        instance[symbol].next();\n        instance[symbol].complete();\n        // We also have to re-assign this property thus in the future\n        // we will be able to create new subject on the same instance.\n        instance[symbol] = null;\n    }\n}\n\nfunction unsubscribe(property) {\n    property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\nfunction unsubscribeIfPropertyIsArrayLike(property) {\n    Array.isArray(property) && property.forEach(unsubscribe);\n}\nfunction decorateNgOnDestroy(ngOnDestroy, options) {\n    return function () {\n        var _a;\n        // Invoke the original `ngOnDestroy` if it exists\n        ngOnDestroy && ngOnDestroy.call(this);\n        // It's important to use `this` instead of caching instance\n        // that may lead to memory leaks\n        completeSubjectOnTheInstance(this, getSymbol());\n        // Check if subscriptions are pushed to some array\n        if (options.arrayName) {\n            return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);\n        }\n        // Loop through the properties and find subscriptions\n        if (options.checkProperties) {\n            for (const property in this) {\n                if ((_a = options.blackList) === null || _a === void 0 ? void 0 : _a.includes(property)) {\n                    continue;\n                }\n                unsubscribe(this[property]);\n            }\n        }\n    };\n}\nfunction decorateProviderDirectiveOrComponent(type, options) {\n    type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n}\nfunction decoratePipe(type, options) {\n    const def = type.ɵpipe;\n    def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n}\nfunction UntilDestroy(options = {}) {\n    return (type) => {\n        if (isPipe(type)) {\n            decoratePipe(type, options);\n        }\n        else {\n            decorateProviderDirectiveOrComponent(type, options);\n        }\n        markAsDecorated(type);\n    };\n}\n\nfunction overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {\n    const originalDestroy = instance[destroyMethodName];\n    if (ngDevMode && isFunction(originalDestroy) === false) {\n        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);\n    }\n    createSubjectOnTheInstance(instance, symbol);\n    instance[destroyMethodName] = function () {\n        originalDestroy.apply(this, arguments);\n        completeSubjectOnTheInstance(this, symbol);\n        // We have to re-assign this property back to the original value.\n        // If the `untilDestroyed` operator is called for the same instance\n        // multiple times, then we will be able to get the original\n        // method again and not the patched one.\n        instance[destroyMethodName] = originalDestroy;\n    };\n}\nfunction untilDestroyed(instance, destroyMethodName) {\n    return (source) => {\n        const symbol = getSymbol(destroyMethodName);\n        // If `destroyMethodName` is passed then the developer applies\n        // this operator to something non-related to Angular DI system\n        if (typeof destroyMethodName === 'string') {\n            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n        }\n        else {\n            ngDevMode && ensureClassIsDecorated(instance);\n            createSubjectOnTheInstance(instance, symbol);\n        }\n        return source.pipe(takeUntil(instance[symbol]));\n    };\n}\nfunction ensureClassIsDecorated(instance) {\n    const prototype = Object.getPrototypeOf(instance);\n    const missingDecorator = !(DECORATOR_APPLIED in prototype);\n    if (missingDecorator) {\n        throw new Error('untilDestroyed operator cannot be used inside directives or ' +\n            'components or providers that are not decorated with UntilDestroy decorator');\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UntilDestroy, untilDestroyed };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}